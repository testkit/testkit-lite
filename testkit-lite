#!/usr/bin/python
#
# Copyright (C) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU General Public License,
# version 2, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place - Suite 330, Boston, MA 02111-1307 USA.
#
# Authors:
#              Tian, Xu <xux.tian@intel.com>
#              Wang, Jing <jing.j.wang@intel.com>
#              Wei, Zhang <wei.z.zhang@intel.com>
#              Zhang, Huihui <huihuix.zhang@intel.com>
#
# Description:
#   test runner startup

import os
import re
import sys
import time
import platform
import ctypes
import xml.etree.ElementTree as etree
from optparse import *
from shutil import copyfile
from tempfile import mktemp 
from datetime import datetime

_j = os.path.join
_e = os.path.exists
_d = os.path.dirname
_b = os.path.basename
_abspath = os.path.abspath

testkit_dir = "/opt/testkit/lite"
if not platform.system() == "Linux":
    testkit_dir = _d(_abspath(__file__))
    sys.path += [_j(testkit_dir)]
    testkit_dir = _j(testkit_dir , "results")

LOG_DIR = testkit_dir
PID_FILE = _j(LOG_DIR , "pid.log")
COMMON_FILTERS = {
        "suite":          [],
        "set":            [],
        "id":             [],
        "type":           [],
        "priority":       [],
        "status":         [],
        "component":      []}

#start testkit-lite in Singleton mode
try:
    with open(PID_FILE, "r") as fd:
        pid = fd.readline().rstrip("\n")
        if pid:
            if platform.system() == "Linux":
                os.kill(int(pid), 9)
                print "[ kill existing testkit-lite, pid: %s ]" % pid
            else:
                kernel32 = ctypes.windll.kernel32
                handle = kernel32.OpenProcess(1, 0, int(pid))
                kill_result = kernel32.TerminateProcess(handle, 0)
                print "[ kill existing testkit-lite, pid: %s ]" % pid
except Exception, e:
    pattern = re.compile('No such file or directory|No such process')
    match = pattern.search(str(e))
    if not match:
        print "[ fail to kill existing testkit-lite, error: %s ]" % e

if not platform.system() == "Linux":
    try:
        if not os.path.exists(LOG_DIR):
            os.makedirs(LOG_DIR)
    except OSError, e:
        print >> sys.stderr, "\n[ create results directory: %s failed, error: %s ]\n" % (LOG_DIR, e)

try:
    with open(PID_FILE, "w") as fd:
        pid = str(os.getpid())
        fd.writelines(pid + '\n')
        os.chmod(PID_FILE, 0666)
except Exception, e:
    print "[ can't create pid log file: %s, error: %s ]" % (PID_FILE, e)
    sys.exit(1)

# detect version option
if "--version" in sys.argv:
    print "[ testkit-lite v2.2.4-4 ]"
    sys.exit(1)

#get test engine, now we only got default engine
if "-E" in sys.argv:
    index = sys.argv.index("-E")
    try:
        engine = sys.argv[index + 1]
        engine = str(engine.strip()).lower()
    except IndexError:
        engine = "default"
else:
    engine = "default"

#init test engine here
try:
    exec "from testkitlite.engines.%s.runner import TRunner" % engine
    print "[ loading %s test engine ]" % engine
except ImportError, e:
    print "[ loading test engine: %s failed, error: %s ]" % (engine, e)
    sys.argv.append("-h")

def varnarg(option, opt_str, value, parser):
    value = []
    import re
    for arg in parser.rargs:
        if re.search('^--.+', arg) or \
           re.search('^-[\D]', arg):
            break
        value.append(arg)
        
    del parser.rargs[:len(value)]
    setattr(parser.values, option.dest, value)

try:
    option_list = [
                    make_option("-f", "--testxml", dest="testxml",
                                action="callback", callback=varnarg,
                                help="Specify the test.xml. If run more the one testxml, just list them all and separate with a whitespace"),
                    make_option("-D", "--dryrun", dest="bdryrun",
                                action="store_true",
                                help="Dry-run the selected test cases"),
                    make_option("-M", "--manual-only", dest="bmanualonly",
                                action="store_true",
                                help="Enable only manual tests"),
                    make_option("-A", "--auto-only", dest="bautoonly",
                                action="store_true",
                                help="Enable only auto tests"),
                    make_option("-o", "--output", dest="resultfile",
                                help="Specify output file for result xml. If more than one testxml provided, results will be merged together to this output file"),
                    make_option("-E", dest="engine", help="Specific test engine"),
                    make_option("-e", dest="exttest", action="store",
                                help="Launch external test with an executable file"),
                    make_option("--fullscreen", dest="fullscreen", action="store_true",
                                help="Run web API test in full screen mode"),
                   make_option("--version", dest="version_info", action="store_true",
                                help="Show version information"),
                  ]
    
    option_list.extend(map(lambda flt: \
                        make_option("--%s" % flt, dest="w%s" % flt, \
                                    action="callback", callback=varnarg, \
                                    help="Select the specified filter-rules : %s" % flt), COMMON_FILTERS))

    try:
        # untrusted behaviour of %%prog
        usage = "%%prog [options] -f <somewhere/test.xml>\n\
examples: %%prog  -f  <somewhere>/test.xml\n\
          %%prog  -f test.xml -D\n\
          %%prog  -f test.xml -A\n\
          %%prog  -f test.xml -M\n\
          %%prog  -f test1.xml test2.xml test3.xml ...\n\
          %%prog  -f test.xml -D -A --type type1 ...\n\
          %%prog  -f test.xml -D -A --type type1 --status ready ...\n\
\n\
    run a webapi package: \n\
          %%prog -f /usr/share/webapi-webkit-tests/tests.xml -e 'WRTLauncher webapi-webkit-tests' -o /tmp/wekit-tests-result.xml --priority P0 --status ready ...\n\
    run both core and webapi packages: \n\
          %%prog -f /usr/share/webapi-webkit-tests/tests.xml /usr/share/tts-bluez-tests/tests.xml -e 'WRTLauncher webapi-webkit-tests' -o /tmp/wekit-tests-result.xml ...\n\
\n\
Note: \n\
          1) One testxml should contains only one <suite> tag, multiple tags are not supported\n\
          2) TestLog is stored to %s/latest\n\
          3) %%prog enables both auto and manual tests by default\n\
          4) Obviously -A and -M are conflict options\n\
          5) -e option does not support -D mode" % (LOG_DIR)
    except:
        usage = None

    # detect non-params
    if len(sys.argv) == 1:
        sys.argv.append("-h")

    parser = OptionParser(option_list=option_list, usage=usage)

    (options, args) = parser.parse_args()

    # detect conflict
    if options.bautoonly and options.bmanualonly:
        raise ValueError("-A and -M are conflict")

    # create runner
    runner = TRunner()
    runner.set_pid_log(PID_FILE)

    # apply dryrun
    if options.bdryrun:
        runner.set_dryrun(options.bdryrun)

    # apply user specify test result file
    if options.resultfile:
        runner.set_resultfile(options.resultfile)

    # apply filter
    wfilters = {}
    for flt in COMMON_FILTERS:
        if eval('options.w%s' % flt):
            wfilters[flt] = eval('options.w%s' % flt)

    if options.fullscreen:
        runner.set_fullscreen(True)

    runner.add_filter_rules(**wfilters)

    if options.exttest:
        runner.set_external_test(options.exttest)

    if not options.testxml:
        print "[ not specify a test xml... ]"
        sys.exit(1)

    # 1) prepare log dir
    if platform.system() == "Linux":
        session = datetime.today().isoformat('-')
    else:
        session = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
    log_dir = _j(LOG_DIR, session)
    latest_dir = _j(LOG_DIR, "latest")
    try:
        if _e(latest_dir):
            os.remove(latest_dir)
        os.makedirs(log_dir)
        if os.name == "posix":
            os.symlink(log_dir, latest_dir)
    except OSError, e:
        print >> sys.stderr, "\n[ create session log directory: %s failed, error: %s ]\n" % (log_dir, e)

    # 2) run test
    # run more than one tests.xml
    # 1. run all auto cases from the xmls
    # 2. run all manual cases from the xmls
    if len(options.testxml) > 1:
        testxmls = set(options.testxml)
        for t in testxmls:
            filename = t
            filename = os.path.splitext(filename)[0]
            filename = filename.split('/')[3]
            filename = "%s.total" % _b(filename)
            resultfile = "%s.xml" % filename
            resultfile = _j(log_dir, resultfile)
            ep = etree.parse(t)
            rt = ep.getroot()
            if options.bautoonly:
                wfilters['execution_type'] = ["auto"]
                runner.add_filter_rules(**wfilters)
            if options.bmanualonly:
                wfilters['execution_type'] = ["manual"]
                runner.add_filter_rules(**wfilters)
            runner.apply_filter(rt)
            # just leave suite and set for merge result
            for suite in ep.getiterator('suite'):
                for set in suite.getiterator('set'):
                    for testcase in set.getiterator('testcase'):
                        set.remove(testcase)
            ep.write(resultfile)
        start_time = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        if not options.bautoonly:
            if options.bmanualonly:
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["manual"]
                        runner.add_filter_rules(**wfilters)
                        runner.run(t, resultdir=log_dir)
                        time.sleep(50)
                    except Exception, e:
                        print e
            else:
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["auto"]
                        runner.add_filter_rules(**wfilters)
                        runner.run(t, resultdir=log_dir)
                        time.sleep(6)
                    except Exception, e:
                        print e
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["manual"]
                        runner.add_filter_rules(**wfilters)
                        runner.run(t, resultdir=log_dir)
                        time.sleep(50)
                    except Exception, e:
                        print e
        else:
            for t in testxmls:
                try:
                    wfilters['execution_type'] = ["auto"]
                    runner.add_filter_rules(**wfilters)
                    runner.run(t, resultdir=log_dir)
                    time.sleep(6)
                except Exception, e:
                    print e
    # run only one tests.xml
    # 1. run all auto cases from the xml
    # 2. run all manual cases from the xml
    else:
        testxml = (options.testxml)[0]
        filename = testxml
        filename = os.path.splitext(filename)[0]
        if platform.system() == "Linux":
            filename = filename.split('/')[3]
        else:
            filename = filename.split('\\')[-2]
        filename = "%s.total" % _b(filename)
        resultfile = "%s.xml" % filename
        resultfile = _j(log_dir, resultfile)
        ep = etree.parse(testxml)
        rt = ep.getroot()
        if options.bautoonly:
            wfilters['execution_type'] = ["auto"]
            runner.add_filter_rules(**wfilters)
        if options.bmanualonly:
            wfilters['execution_type'] = ["manual"]
            runner.add_filter_rules(**wfilters)
        runner.apply_filter(rt)
        # just leave suite and set for merge result
        for suite in ep.getiterator('suite'):
                for set in suite.getiterator('set'):
                    for testcase in set.getiterator('testcase'):
                        set.remove(testcase)
        ep.write(resultfile)
        start_time = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        if not options.bautoonly:
            if options.bmanualonly:
                try:
                    wfilters['execution_type'] = ["manual"]
                    runner.add_filter_rules(**wfilters)
                    runner.run(testxml, resultdir=log_dir)
                except Exception, e:
                    print e
            else:
                try:
                    wfilters['execution_type'] = ["auto"]
                    runner.add_filter_rules(**wfilters)
                    runner.run(testxml, resultdir=log_dir)
                    time.sleep(6)
                    wfilters['execution_type'] = ["manual"]
                    runner.add_filter_rules(**wfilters)
                    runner.run(testxml, resultdir=log_dir)
                except Exception, e:
                    print e
        else:
            try:
                wfilters['execution_type'] = ["auto"]
                runner.add_filter_rules(**wfilters)
                runner.run(testxml, resultdir=log_dir)
            except Exception, e:
                print e
    try:
        end_time = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        runner.merge_resultfile(start_time, end_time, log_dir)
    except Exception, e:
        print e

except KeyboardInterrupt, e:
    print >> sys.stderr, "\n[ exiting on user cancel ]\n"
    sys.exit(1)
except Exception, e:
    print >> sys.stderr, e
    sys.exit(1)
